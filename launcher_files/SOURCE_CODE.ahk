
;                __             __   __      __   __          __   ___  __   __                          __        ___  __  
;\  /  /\  |\ | / _` |  |  /\  |__) |  \    |__) |__) | |\ | /  ` |__  /__` /__`    |     /\  |  | |\ | /  ` |__| |__  |__) 
; \/  /~~\ | \| \__> \__/ /~~\ |  \ |__/    |    |  \ | | \| \__, |___ .__/ .__/    |___ /~~\ \__/ | \| \__, |  | |___ |  \
;___________________________________________________________________________________________________________________________
 
;This program is a GUI launcher for Vanguard Princess that adds various window modes to the game and translates the options menus from Japanese to English. 
;After the GUI launcher is used to start either the game or LilithPort (or VanguardOnline) it will monitor the game status in the background and allow the window modes to be changed and/or translate the options menus. 
;When both the game and LilithPort (or VanguardOnline) is closed then this program will automatically close. 

;Installation: Place "VANGUARD_PRINCESS_LAUNCHER.exe" and the "launcher_files" folder into your game's install folder.  
;Note: If you are using the freeware version of the game (vanpri108e.exe) and want online multiplayer, then install LilithPort: 
;https://github.com/oldmud0/LilithPort/releases/tag/v1.08-pre1
;Note 2: If you are using the Steam version of the game, then it already comes with a modified version of LilithPort called VanguardOnline.
;Note 3: The GUI launcher should automatically obtain the file paths for the game and LilithPort (or VanguardOnline) if it was placed in the correct folder and those files already exist.  If it doesn't then you can set the file paths in the GUI launcher itself.
;Note 4: "LilithPort" is used to refer to both LilithPort and VanguardOnline for the rest of this script since they are basically the same. 

;Supported window modes: Fullscreen, Borderless Fullscreen (4:3), Borderless Fullscreen (Stretched), Borderless Fullscreen (Integer Scaled), Default Window
;Note: The various Borderless Fullscreen modes should all look less blurry than the fullscreen mode due to the way the game handles upscaling. 
;Note 2: If the game executable is named "vanpri.exe" then the script assumes that the Steam version that already has fullscreen support is being used, so it just activates the existing fullscreen mode without additional modifications. 
;Note 3: If the game executable is named anything other than "vanpri.exe", then it assumes the freeware version of the game is being used and strips off the window borders and menu bar so the game goes into fullscreen mode properly. 
;Note 4: Borderless Fullscreen (integer scaled) is a mode that prevents upscale blur by multiplying the game resolution by an integer.  This means that the pixels are either doubled, tripled, quadrupled, etc. to fit within your screen size, but never scaled by a decimal amount that would lead to blur.  However, for Vanguard Princess in particular the benefit of this mode over Borderless Fullscreen (4:3) doesn't seem to be that big. 

;Compatibility: It should be compatible with any version of Vanguard Princess and Lilithport.  It could potentially even work for other games if you set the offline game path to the executable of a different game in the GUI launcher. 

;Potential issue: If you have a really slow computer then .dll function calls could desync with the rest of the code and cause window modes to display incorrectly.  A default wait time of 1500ms was set between window operations in order to try to mitigate this issue for the majority of users.  If you are experiencing problems, then you can increase this wait time by editing the "WindowChangeBufferTimeValue=1500" field in "./launcher_files/launcher_settings.ini".  For example, changing this field to "WindowChangeBufferTimeValue=3000" would cause the program to wait 3000ms (3 seconds) between window operations, and may give your slow computer enough time to keep up.  Note that "launcher_settings.ini" will not be there until it is generated by the GUI launcher. 

;Potential issue 2: If for some reason you can't use the function keys on your keyboard (like F5), then you can modify "F5::" in this script to another hotkey and run this script instead of "VANGUARD_PRINCESS_LAUNCHER.exe".
;Note: You need to install AutoHotKey to run this script directly.
;Note 2: You would need to move the modified script from the "launcher_files" folder to the game's install folder for it to work properly. 
;https://www.autohotkey.com/docs/KeyList.htm

;Potential issue 3: If the options menus aren't translating, then set your system locale to Japanese.  Your operating system will still be in English after this, but the Japanese text should now render and be translated correctly.  However, this shouldn't be necessary since this program is designed to translate broken Japanese text too. 

;Launcher version: 1.0

;AutoHotKey version: 1.1.33.10

;Author: LlamaMaster (Syphilis_Buddy)

;Date created: January 27, 2022

;Feel free to use this code for other projects without asking.

;------------------------------------------------------------------------------------------

;This section contains the default code that appears when a new AutoHotKey script is made. 

#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
; #Warn  ; Enable warnings to assist with detecting common errors.
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.

;------------------------------------------------------------------------------------------

;Ignores attempts to launch the script a second time if it is already running. 
#SingleInstance Ignore

;Makes it so window titles must be an exact match for commands to run on them. 
;https://www.autohotkey.com/docs/commands/SetTitleMatchMode.htm
SetTitleMatchMode, 3

;---------------------------------------

;This function changes the game screen mode to "windowed" in the game.ini file if it isn't already so the script can run correctly. 
;https://www.autohotkey.com/board/topic/67398-need-help-quick-editing-of-a-text-file/
ResetGameScreenMode() {
	
	FileRead, Var1, game.ini
	StringReplace, Var2, Var1, GameScreenMode=1, GameScreenMode=0, All
	FileDelete, game.ini
	FileAppend, %Var2%, game.ini
	
	Return
}

;Calls the function above and executes it.
ResetGameScreenMode()

;---------------------------------------

;This function reads the settings file for the launcher or creates a new one. 
;Note: ByRef makes a variable global.
ManageSettingsFile(ByRef GamePath, ByRef LilithPortPath, ByRef TranslateMenus, ByRef WindowChangeBufferTime, ByRef GameExeName) {

	if FileExist("launcher_files\launcher_settings.ini")
	{
		;Reads the launcher settings file and puts the string in a variable.
		FileRead, LauncherSettingsString, launcher_files\launcher_settings.ini
	
		;Splits each line of the string into a separate string and then puts them into an array. 
		;https://www.autohotkey.com/boards/viewtopic.php?t=38661
		SettingsArray := StrSplit(LauncherSettingsString, "`n", "`r")
	
		;Obtains the information to the right of the equals sign on each line. 
		GamePath := StrSplit(SettingsArray[1],"=")[2]
		LilithPortPath := StrSplit(SettingsArray[2],"=")[2]
		TranslateMenus := StrSplit(SettingsArray[3],"=")[2]
		WindowChangeBufferTime := StrSplit(SettingsArray[4],"=")[2]
		
		;Obtains the game .exe name by returning the text that occurs after the last "\" in the GamePath string. 
		GamePathArray := StrSplit(GamePath, "\")
		GameExeName := GamePathArray[GamePathArray.MaxIndex()]
	}
	else
	{
		if FileExist("vanpri.exe")
		{
			GameExeName = vanpri.exe
		}
		else if FileExist("vanpri108e.exe")
		{
			GameExeName = vanpri108e.exe
		}
		else
		{
			GameExeName = unknown
		}
	
		if FileExist("VanguardOnline.exe")
		{
			LilithPortExeName = VanguardOnline.exe
		}
		else if FileExist("LilithPort.exe")
		{
			LilithPortExeName = LilithPort.exe
		}
		else
		{
			LilithPortExeName = unknown
		}

;Creates a settings file with default values if one doesn't already exist. 
;Note: This section isn't tabbed because tabs carry over into the appended string.
FileAppend,
(
GamePathString=%A_ScriptDir%\%GameExeName%
LilithPortPathString=%A_ScriptDir%\%LilithPortExeName%
TranslateMenusOption=1
WindowChangeBufferTimeValue=1500
), launcher_files\launcher_settings.ini

		GamePath = %A_ScriptDir%\%GameExeName%
		LilithPortPath = %A_ScriptDir%\%LilithPortExeName%
		TranslateMenus := true
		WindowChangeBufferTime := 1500
	}

	Return
}

;Calls the function above to create the launcher settings variables that the rest of the script needs.
ManageSettingsFile(GamePath, LilithPortPath, TranslateMenus, WindowChangeBufferTime, GameExeName)

;---------------------------------------

;This section creates and operates the GUI launcher.
;https://www.youtube.com/watch?v=5pjRX5q7q2I

;Creates a GUI with a black background.
Gui, Color, black

;Randomly generates either a 1, 2, or 3. 
Random, ImageNumber, 1, 3

;Adds a random background image to the GUI based on the number generated above. 
Gui, Add, Picture, x0 y0 w1100 h688, .\launcher_files\background_%ImageNumber%.png

;Adds an image of the logo to the GUI.
Gui, Add, Picture, x679 y505 +BackgroundTrans, .\launcher_files\vanguard_princess_logo.png

;Initializes variables that are used to keep track of whether a button is glowing or not.
PlayOnlineImageGlowing := false
PlayOfflineImageGlowing := false
SetGamePathImageGlowing := false
ViewManualImageGlowing := false

;Puts the image file path strings that are used for the GUI into variables. 
PlayOnlineShadowImage = .\launcher_files\play_online_shadow.png
PlayOnlineGlowImage = .\launcher_files\play_online_glow.png
PlayOfflineShadowImage = .\launcher_files\play_offline_shadow.png
PlayOfflineGlowImage = .\launcher_files\play_offline_glow.png
SetGamePathShadowImage = .\launcher_files\set_game_path_shadow.png
SetGamePathGlowImage = .\launcher_files\set_game_path_glow.png
ViewManualShadowImage = .\launcher_files\view_manual_shadow.png
ViewManualGlowImage = .\launcher_files\view_manual_glow.png

;Adds image buttons and their controls to the GUI. 
;gImageButton means "go to" the ImageButton label (where "label" basically means a function).
;vImageControl means that this whole line of code is a control that is assigned to a variable with the name ImageControl.
;https://www.autohotkey.com/board/topic/68694-on-mouse-over-picture/
;https://www.autohotkey.com/board/topic/48681-image-as-button/
Gui, Add, Picture, hwndImageID1 vImageControl gImageButton BackgroundTrans x727 y71, %PlayOnlineShadowImage%
Gui, Add, Picture, hwndImageID2 vImageControl2 gImageButton2 BackgroundTrans, %PlayOfflineShadowImage%
Gui, Add, Picture, hwndImageID3 vImageControl3 gImageButton3 BackgroundTrans, %SetGamePathShadowImage%
Gui, Add, Picture, hwndImageID4 vImageControl4 gImageButton4 BackgroundTrans, %ViewManualShadowImage%

;Checks to see if the mouse cursor is over an image button every 10ms.
SetTimer, MouseOverPicture, 10

;Displays the GUI. 
Gui, Show, w1100 h688, Vanguard Princess Launcher  (ver. 1.0)

;Ends the auto-execution portion of the script so the labels below don't get executed unless they are called by the controls above. 
;Note: Labels don't behave like normal functions.  Labels just indicate a place in the script to "jump" to during execution.  If a label appears in the auto-execution portion of the script, then the code inside that label will be executed even if no controls reference the label. 
Return

;Closes the script when the GUI launcher window is closed. 
GuiClose:

	ExitApp
	
	Return

;Switches each image button to a glowing version of the image if the mouse cursor is placed over it. 
MouseOverPicture:

	;Submits the GUI's data state.
	Gui, Submit, NoHide
	
	;Stores the mouse cursor's current position in a variable. 
	MouseGetPos,,,, MousePositionID, 2

	if (MousePositionID = ImageID1)
	{
		if (PlayOnlineImageGlowing = false)
		{
			GuiControl,, ImageControl, %PlayOnlineGlowImage%
			PlayOnlineImageGlowing := true
		}
	}
	else
	{
		if (PlayOnlineImageGlowing = true)
		{
			GuiControl,, ImageControl, %PlayOnlineShadowImage%
			PlayOnlineImageGlowing := false
		}
	}

	if (MousePositionID = ImageID2)
	{
		if (PlayOfflineImageGlowing = false)
		{
			GuiControl,, ImageControl2, %PlayOfflineGlowImage%
			PlayOfflineImageGlowing := true
		}
	}
	else
	{
		if (PlayOfflineImageGlowing = true)
		{
			GuiControl,, ImageControl2, %PlayOfflineShadowImage%
			PlayOfflineImageGlowing := false
		}
	}

	if (MousePositionID = ImageID3)
	{
		if (SetGamePathImageGlowing = false)
		{
			GuiControl,, ImageControl3, %SetGamePathGlowImage%
			SetGamePathImageGlowing := true
		}
	}
	else
	{
		if (SetGamePathImageGlowing = true)
		{
			GuiControl,, ImageControl3, %SetGamePathShadowImage%
			SetGamePathImageGlowing := false
		}
	}

	if (MousePositionID = ImageID4)
	{
		if (ViewManualImageGlowing = false)
		{
			GuiControl,, ImageControl4, %ViewManualGlowImage%
			ViewManualImageGlowing := true
		}
	}
	else
	{
		if (ViewManualImageGlowing = true)
		{
			GuiControl,, ImageControl4, %ViewManualShadowImage%
			ViewManualImageGlowing := false
		}
	}

	Return

;The "Play Online" button that closes the GUI launcher and runs LilithPort.
ImageButton:

	;Stops the timer and prevents the mouse cursor movement from being tracked any further. 
	SetTimer, MouseOverPicture, Delete

	;Closes the GUI and removes it from memory. 
	Gui, Destroy
	Gui, 2: Destroy
	
	;Launches LilithPort and assigns the program ID to a variable.
	Run, %LilithPortPath%,,, LilithPortPid
	
	;Waits for the LilithPort window to exist before the rest of the code is executed.
	WinWait, ahk_pid %LilithPortPid%
	
	Goto, RestOfScript

	Return

;The "Play Offline" button that closes the GUI launcher and runs the game.
ImageButton2:

	;Stops the timer and prevents the mouse cursor's movement from being tracked any further. 
	SetTimer, MouseOverPicture, Delete

	;Closes the GUI and removes it from memory. 
	Gui, Destroy
	Gui, 2: Destroy
	
	;Launches the game and assigns the program ID to a variable.
	Run, %GamePath%,,, GamePid
	
	;Waits for the game window to exist before the rest of the code is executed.
	WinWait, ahk_pid %GamePid%
	
	;Gets the game window handle ID using the program ID so it can be passed to Windows .dll functions.
	;https://www.autohotkey.com/boards/viewtopic.php?t=35527
	WinGet, GameHwnd, ID, ahk_pid %GamePid%

	Goto, RestOfScript

	Return

;The "Set Game Path" button that creates a secondary GUI for modifying the launcher settings file.
ImageButton3:

	;Ensures that duplicate settings windows can't be opened.
	Gui, 2: +LastFoundExist

	;Creates a new secondary GUI.
	;https://www.autohotkey.com/board/topic/62202-guiclose/
	Gui, 2: New,, Settings

	Gui, 2: Color, White
	Gui, 2: Font, s14 cBlack
	Gui, 2: Add, Text, x10 y10, Game .exe path:

	Gui, 2: Add, Edit, vEditboxControl w578 r1 -wrap section, %GamePath%
	Gui, 2: Add, Button, vGamePathButtonControl gGamePathButton x+10 ys w32 h32, ...

	Gui, 2: Add, Text, xs, LilithPort (or VanguardOnline) .exe path:

	Gui, 2: Add, Edit, vEditboxControl2 w578 r1 -wrap xs section, %LilithPortPath%
	Gui, 2: Add, Button, vLilithPortPathButtonControl gLilithPortPathButton x+10 ys w32 h32, ...

	Gui, 2: Add, Text, xs, %A_Space%
	Gui, 2: Add, CheckBox, Checked%TranslateMenus% vCheckboxControl gTranslateMenusCheckbox xs, Translate options menus to English

	Gui, 2: Add, Button, vApplyControl gApplyButton x466 y188 w77 h40, Apply
	Gui, 2: Add, Button, gCancelButton x553 y188 w77 h40, Cancel

	GuiControl, Focus, ApplyControl
	
	Gui, 2: Show, w640 h238

	Return

;The "View Manual" button that opens the game manual PDF.
ImageButton4:
	
	;Launches the manual that comes with the Steam version of the game if that is the version of the game being used, or the manual that comes with the launcher if it isn't. 
	if (GameExeName = "vanpri.exe")
	{
		Run, readme\Game_Manual.pdf
	}
	else
	{
		Run, launcher_files\Game_Manual.pdf
	}

	Return

;The "..." button next to the game path field in the secondary GUI.
GamePathButton:

	;Opens a file selection window. 
	;https://lexikos.github.io/v2/docs/commands/FileSelect.htm
	FileSelectFile, SelectedFile, 3, %A_ScriptDir%, Select game executable, Executables (*.exe)

	GuiControl,, EditboxControl, %SelectedFile%

	Return

;The "..." button next to the LilithPort path field in the secondary GUI.
LilithPortPathButton:

	;Opens a file selection window. 
	FileSelectFile, SelectedFile2, 3, %A_ScriptDir%, Select LilithPort executable, Executables (*.exe)

	GuiControl,, EditboxControl2, %SelectedFile2%

	Return

;The checkbox for translating menus in the secondary GUI.
TranslateMenusCheckbox:

	;Submits the GUI's data state so we can read its variables.
	Gui, Submit, NoHide

	;Activates if box is unchecked.
	if (CheckboxControl = 0)
	{
		TranslateMenus := false
	}

	;Activates if box is checked.
	if (CheckboxControl = 1)
	{
		TranslateMenus := true
	}

	Return

;The "Apply" button in the secondary GUI.
ApplyButton:

	;Submits the GUI's data state so its variables can be read.
	Gui, Submit, NoHide

	;Deletes the existing launcher settings file so it can be created again with new settings. 
	FileDelete, launcher_files\launcher_settings.ini

;Creates a new launcher settings file from the fields in the secondary GUI window. 
;Note: If you want to change "WindowChangeBufferTimeValue", then you have to edit "launcher_settings.ini" manually and restart the script. 
;Note 2: This section isn't tabbed because tabs carry over into the appended string.
FileAppend,
(
GamePathString=%EditboxControl%
LilithPortPathString=%EditboxControl2%
TranslateMenusOption=%TranslateMenus%
WindowChangeBufferTimeValue=%WindowChangeBufferTime%
), launcher_files\launcher_settings.ini

	;Reloads the settings file and updates the information in the variables for the rest of the script 
	ManageSettingsFile(GamePath, LilithPortPath, TranslateMenus, WindowChangeBufferTime, GameExeName)
	
	Gui, 2: Destroy

	Return

;The "Cancel" button in the secondary GUI.
CancelButton:

	Gui, 2: Destroy

	Return

;Destroys the secondary GUI and removes it from memory if it is closed manually.
2GuiClose:

	Gui, 2: Destroy

	Return

;---------------------------------------

;This section contains functions for managing the game and LilithPort windows.

;This function adds a fake menu bar button that is used to show which hotkeys can be used to change window modes.
;https://www.autohotkey.com/boards/viewtopic.php?t=35527
;https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-appendmenua
AddMenuPopup(hWnd, MenuName) {
	
	MF_POPUP = 16
	
	hItem := DllCall("CreateMenu")
	hMenu := DllCall("GetMenu", "Ptr", hWnd, "Ptr")
	
	DllCall("AppendMenu", "Ptr", hMenu, "UInt", MF_STRING, "UPtr", hItem, "Str", MenuName)
	DllCall("SetMenu", "Ptr", MenuName, "Ptr", hMenu)
	DllCall("DrawMenuBar", "Ptr", hWnd)
	
	Return
}
	
;This function disables the "Window" menu options built into the game since they are broken or incompatible with this script.
;https://www.autohotkey.com/boards/viewtopic.php?t=34907
DisableMenuItem(hWnd, MenuNumber, SubMenuNumber) {
	
	hMenuBar := DllCall("user32\GetMenu", Ptr, hWnd, Ptr)
	hSubMenu := DllCall("user32\GetSubMenu", Ptr, hMenuBar, Int, MenuNumber, Ptr)
	
	DllCall("EnableMenuItem", Ptr, hSubMenu, UInt, SubMenuNumber, UInt, 0x403)
	
	Return
}

;This function translates the game settings menu.
;Note: The "Number Of Rounds (Team Play)" setting appears to do nothing in the game, but it is translated here just because it is in the menu. 
;Note 2: The text locations were found using AutoHotKey's Window Spy program.
;Note 3: This code should run regardless of if the Japanese text renders correctly in the menus or not, but if it doesn't then you may need to change your system locale to Japanese. 
;https://www.autohotkey.com/docs/commands/ControlSetText.htm
TranslateGameMenu() {

	if (WinExist("ゲーム設定") or WinExist("?????"))
	{
		if WinExist("ゲーム設定")
		{
			WindowTitle = ゲーム設定
		}
		else if WinExist("?????")
		{
			WindowTitle = ?????
		}
		
		ControlSetText, Button1, OK, %WindowTitle%
		ControlSetText, Button2, Cancel, %WindowTitle%
		
		ControlSetText, Button3, Select Stage (Versus Mode), %WindowTitle%
		ControlSetText, Button4, Stage, %WindowTitle%
		ControlSetText, Button5, Number Of Rounds (Versus Mode), %WindowTitle%
		ControlSetText, Static10, Rounds, %WindowTitle%
		ControlSetText, Button6, Number Of Rounds (Team Play) (See Launcher Readme), %WindowTitle%
		ControlSetText, Static9, Rounds, %WindowTitle%
		ControlSetText, Button7, Game Speed (Default = 10) (Fastest = 1) (Slowest = 20), %WindowTitle%
		ControlSetText, Static5, +, %WindowTitle%
		ControlSetText, Static6, -, %WindowTitle%
		ControlSetText, Button8, Timer (Default = 60) (Off = 0), %WindowTitle%
		ControlSetText, Static7, <, %WindowTitle%
		ControlSetText, Static8, >, %WindowTitle%
		ControlSetText, Button9, Game Controller, %WindowTitle%
		
		WinSetTitle, %WindowTitle%,, Game Settings
	}
	
	Return
}

;This function translates the keyboard settings menu.
TranslateKeyboardMenu() {
	
	if (WinExist("キーコンフィグ（キーボード）") or WinExist("???????(?????)"))
	{
		if WinExist("キーコンフィグ（キーボード）")
		{
			WindowTitle = キーコンフィグ（キーボード）
		}
		else if WinExist("???????(?????)")
		{
			WindowTitle = ???????(?????)
		}
		
		ControlSetText, Button1, OK, %WindowTitle%
		ControlSetText, Button2, Cancel, %WindowTitle%
		ControlSetText, Button26, Default, %WindowTitle%
		
		ControlSetText, Button3, Player 1, %WindowTitle%
		ControlSetText, Static15, Up, %WindowTitle%
		ControlSetText, Static13, Left, %WindowTitle%
		ControlSetText, Static14, Right, %WindowTitle%
		ControlSetText, Static16, Down, %WindowTitle%
		ControlSetText, Static4, D - Assist, %WindowTitle%
		ControlSetText, Static5, E - Parry, %WindowTitle%
		ControlSetText, Static6, F - Practice, %WindowTitle%
		ControlSetText, Static1, A - Weak, %WindowTitle%
		ControlSetText, Static2, B - Normal, %WindowTitle%
		ControlSetText, Static3, C - Strong, %WindowTitle%
		
		ControlSetText, Button14, Player 2, %WindowTitle%
		ControlSetText, Static19, Up, %WindowTitle%
		ControlSetText, Static17, Left, %WindowTitle%
		ControlSetText, Static18, Right, %WindowTitle%
		ControlSetText, Static20, Down, %WindowTitle%
		ControlSetText, Static10, D - Assist, %WindowTitle%
		ControlSetText, Static11, E - Parry, %WindowTitle%
		ControlSetText, Static12, F - Practice, %WindowTitle%
		ControlSetText, Static7, A - Weak, %WindowTitle%
		ControlSetText, Static8, B - Normal, %WindowTitle%
		ControlSetText, Static9, C - Strong, %WindowTitle%
		
		WinSetTitle, %WindowTitle%,, Keyboard Settings
	}
	
	Return
}

;This function translates the joystick (game controller) settings menu.
TranslateJoystickMenu() {
	
	if (WinExist("ジョイスティック（ボタン配置設定）") or WinExist("????????(???????)"))
	{
		if WinExist("ジョイスティック（ボタン配置設定）")
		{
			WindowTitle = ジョイスティック（ボタン配置設定）
		}
		else if WinExist("????????(???????)")
		{
			WindowTitle = ????????(???????)
		}
		
		ControlSetText, Button1, OK, %WindowTitle%
		ControlSetText, Button2, Cancel, %WindowTitle%
		ControlSetText, Button27, Default, %WindowTitle%
		
		ControlSetText, Button3, Player 1, %WindowTitle%
		ControlSetText, Static4, D - Assist, %WindowTitle%
		ControlSetText, Static5, E - Parry, %WindowTitle%
		ControlSetText, Static6, F - Practice, %WindowTitle%
		ControlSetText, Static1, A - Weak, %WindowTitle%
		ControlSetText, Static2, B - Normal, %WindowTitle%
		ControlSetText, Static3, C - Strong, %WindowTitle%
		
		ControlSetText, Button14, Player 2, %WindowTitle%
		ControlSetText, Static10, D - Assist, %WindowTitle%
		ControlSetText, Static11, E - Parry, %WindowTitle%
		ControlSetText, Static12, F - Practice, %WindowTitle%
		ControlSetText, Static7, A - Weak, %WindowTitle%
		ControlSetText, Static8, B - Normal, %WindowTitle%
		ControlSetText, Static9, C - Strong, %WindowTitle%
		
		WinSetTitle, %WindowTitle%,, Joystick (Game Controller) Settings
	}
	
	Return
}

;This function temporarily prevents hotkeys from being pressed and pauses the execution of the script for a specified amount of time in order to prevent glitches while the window modes are being changed.
FreezeScript(WindowChangeBufferTime) {

	;Temporarily prevents the hotkeys in the script from being pressed.
	;Note: This also temporarily re-enables any hotkeys in the game that were disabled by this script. 
	Suspend, On
	
	;Turns off the loop that continuously monitors the game window.
	;Note: It is unknown why this is necessary, but if the loop is running while the window mode is being changed then GUI errors occur randomly. 
	SetTimer ManageGameWindow, Off
	
	;Prevents the code from being executed further until a specified amount of time has passed. 
	Sleep, %WindowChangeBufferTime%
	
	;Turns on the loop that continuously monitors the game window.
	SetTimer ManageGameWindow, On
	
	;Re-enables the ability to press the hotkeys in the script. 
	;Note: This also re-disables any hotkeys in the game that were disabled by this script. 
	Suspend, Off
	
	Return
}

;This function enters or exits the fullscreen mode.
ToggleFullscreen(WindowChangeBufferTime) {
	
	;Temporarily prevents the hotkeys in the script from being pressed.
	;Note: This also temporarily re-enables any hotkeys in the game that were disabled by this script. 
	Suspend, On
	
	;Turns off the loop that continuously monitors the game window.
	;Note: It is unknown why this is necessary, but if the loop is running while the window mode is being changed then GUI errors occur randomly. 
	SetTimer ManageGameWindow, Off
	
	;Presses F4 in order to enter or exit the fullscreen mode.
	;Note: Send !{Enter} presses Alt+Enter, which is an equivalent way to enter fullscreen mode that may work for other games. 
	Send {F4}
	
	;Prevents the code from being executed further until a specified amount of time has passed. 
	Sleep, %WindowChangeBufferTime%
	
	;Turns on the loop that continuously monitors the game window.
	SetTimer ManageGameWindow, On
	
	;Re-enables the ability to press the hotkeys in the script. 
	;Note: This also re-disables any hotkeys in the game that were disabled by this script. 
	Suspend, Off
	
	Return
}

;This function removes the window borders and menu bar from the game window. 
HideBorders(ByRef WindowPositionX, ByRef WindowPositionY, ByRef WindowWidth, ByRef WindowHeight, ByRef hMenu, ByRef BordersHidden) {
	
	;Stores the window's current location and size in variables so the window can be returned to its original state later.
	WinGetPos, WindowPositionX, WindowPositionY, WindowWidth, WindowHeight
	
	;Removes window borders.
	WinSet, Style, -0xC40000, A

	;Stores the menu bar in a variable so it can be shown later. 
	hMenu := DllCall("GetMenu", ptr, WinActive("A"))

	;Removes menu bar.
	DllCall("SetMenu", ptr, WinActive("A"), ptr, 0)
	
	BordersHidden := true
	
	Return
}

;This function adds the window borders and menu bar that were removed by the previous function back to the game window. 
ShowBorders(WindowChangeBufferTime, WindowPositionX, WindowPositionY, WindowWidth, WindowHeight, hMenu, ByRef BordersHidden) {

	;Shows window borders.
	WinSet, Style, +0xC40000, A
	
	;Shows menu bar.
	DllCall("SetMenu", ptr, WinActive("A"), ptr, hMenu)
	
	;Disables all hotkeys for 1.5 seconds (or whatever "WindowChangeBufferTimeValue" is set to in "launcher_settings.ini") and temporarily pauses execution of the script in order to give the DllCall above enough time to finish before the window is resized with the WinMove command below or another hotkey.
	;Note: This also means that the game's default hotkeys that were disabled (like F4 and Alt+Enter) will be active again for 1.5 seconds, which means the user can press those keys and screw up the window during this period. 
	FreezeScript(WindowChangeBufferTime)
	
	;Resizes the game window.
	WinMove,,,,, %WindowWidth%, %WindowHeight%
	
	;Repositions the game window.
	WinMove,,, %WindowPositionX%, %WindowPositionY%
	
	BordersHidden := false
	
	Return
}

;This function creates a black background GUI element that is placed over everything on screen except the game window in order to "fake" the fullscreen borderless window effect. 
ShowBlackBackground() {

	Gui, 3: +LastFoundExist
	Gui, 3: New,, BlackBackground
	Gui, 3: Color, Black
	Gui, 3: +AlwaysOnTop +ToolWindow -Caption +HwndBlackBackgroundHandle
	Gui, 3: Show, w%A_ScreenWidth% h%A_ScreenHeight% x0 y0

	Return
}

;This function initializes the variables that are used to keep track of the status of the game window. 
InitializeWindowVariables(ByRef MenuBarModified, ByRef BordersHidden, ByRef GameWindowActive, ByRef GameExitCleanupCompleted, ByRef FullscreenActive, ByRef BorderlessFullscreenActive, ByRef Borderless4x3Active, ByRef BorderlessStretchedActive, ByRef BorderlessIntegerActive) {

	;Initializes the variables that keep track of the current game window state. 
	MenuBarModified := false
	BordersHidden := false
	GameWindowActive := false
	GameExitCleanupCompleted := false
	
	;Initializes the variables that keep track of the current game window mode. 
	FullscreenActive := false
	BorderlessFullscreenActive := false
	Borderless4x3Active := false
	BorderlessStretchedActive := false
	BorderlessIntegerActive := false

	Return
}

;---------------------------------------

;This code runs after the GUI launcher opens the game or LilithPort. 
RestOfScript:

	;Initializes the variables that are used to keep track of the status of the game window. 
	InitializeWindowVariables(MenuBarModified, BordersHidden, GameWindowActive, GameExitCleanupCompleted, FullscreenActive, BorderlessFullscreenActive, Borderless4x3Active, BorderlessStretchedActive, BorderlessIntegerActive)
	
	;Checks the game window every 250ms to see if code in the label below needs to be executed.
	SetTimer ManageGameWindow, 250
	
	Return
	
ManageGameWindow:

	;Edits the menu bar if the game is running.
	if WinExist("ahk_pid " GamePid)
	{
		if (MenuBarModified = false)
		{
			;Retrieves the timestamp of the last time the game.ini file was modified.
			;Note: Launching the game doesn't modify the game.ini file, but the ResetGameScreenMode() function and closing the game does.  This timestamp is taken here in order to differentiate between when the game edits the game.ini file itself and when the ResetGameScreenMode() function does.  
			;Note 2: Checking modification times is necessary for slower computers because an arbitrary amount of time can pass before the closed game can modify the game.ini file, so the script has to wait for the game to be done saving to the file before the script can edit the file itself with the ResetGameScreenMode() function. 
			;https://www.autohotkey.com/docs/commands/FileGetTime.htm
			FileGetTime, GameLaunchSettingsFileModificationTime, game.ini, M
			
			;Temporarily prevents the hotkeys in the script from being pressed while the menu bar is being modified with the code below. 
			;Note: This also temporarily re-enables any hotkeys in the game that were disabled by this script. 
			Suspend, On
			
			;Pauses execution for specified amount of time in order to ensure that the game has loaded in fully before the window is modified with the code below. 
			Sleep, %WindowChangeBufferTime%
			
			;Adds fake menu bar buttons that show which hotkeys can be used to change window modes. 
			AddMenuPopup(GameHwnd, "F5 = Fullscreen     F6 = Borderless Fullscreen (4:3)")
			AddMenuPopup(GameHwnd, "F7 = Borderless Fullscreen (stretched)     F8 = Borderless Fullscreen (integer scaled)     F9 = Default Window")

			;Disables the "Window" menu options built into the game since they are broken or incompatible with this script.
			DisableMenuItem(GameHwnd, 0, 0)
			DisableMenuItem(GameHwnd, 0, 1)

			;Pauses execution for specified amount of time in order to ensure that the menu bar has been modified fully before hotkeys are re-enabled with the code below.
			Sleep, %WindowChangeBufferTime%
			
			;Re-enables the ability to press the hotkeys in the script. 
			;Note: This also re-disables any hotkeys in the game that were disabled by this script. 
			Suspend, Off

			MenuBarModified := true
		}
		
		if (TranslateMenus = true)
		{
			;Translates the Japanese text in the "Option" menus.
			TranslateGameMenu()
			TranslateKeyboardMenu()
			TranslateJoystickMenu()
		}
	}

	;Reinitializes the program ID, window handle, and game window status variables each time the game is launched and relaunched by LilithPort.
	if !WinExist("ahk_pid " GamePid)
	{
		if WinExist("ahk_exe " GamePath)
		{
			;Gets the new program and window handle ID's that are generated when the game is relaunched. 
			WinGet, GamePid, PID, ahk_exe %GamePath%
			WinGet, GameHwnd, ID, ahk_exe %GamePath%
				
			;Reinitializes the variables that are used to keep track of the status of the game window. 
			InitializeWindowVariables(MenuBarModified, BordersHidden, GameWindowActive, GameExitCleanupCompleted, FullscreenActive, BorderlessFullscreenActive, Borderless4x3Active, BorderlessStretchedActive, BorderlessIntegerActive)

			MenuBarModified := false
		}
	}
	
	;Closes the script if the game window or LilithPort is not running. 
	if !WinExist("ahk_pid " GamePid)
	{
		if !WinExist("ahk_pid " LilithPortPid)
		{
			;Pauses execution for a specified amount of time before another check is done to see if LilithPort or the game is still running. 
			;Note: This is necessary because VanguardOnline (which is made from LilithPort) has window transitions, and if a single check was used to see if the VanguardOnline window still existed, then it is possible that the check would happen right when the window transition occurred and falsely report that VanguardOnline has closed.
			;Note 2: The last check to see if the game is running is make sure the script still runs if the user clicks "Play Online" in the GUI launcher, and then "Play" on the VanguardOnline welcome screen, which would close VanguardOnline and open the game. 
			Sleep, %WindowChangeBufferTime%
			
			if !WinExist("ahk_pid " LilithPortPid)
			{
				if !WinExist("ahk_exe " GamePath)
				{
					ExitApp
				}
			}
		}
	}
	
	;Removes the black background and resets the screen mode in the game.ini file each time the game is closed while LilithPort is still running.
	if !WinExist("ahk_pid " GamePid)
	{
		if WinExist("ahk_pid " LilithPortPid)
		{
			if (MenuBarModified = true)
			{
				if (GameExitCleanupCompleted = false)
				{
					;Removes the black background.
					Gui, 3: Destroy
					
					;Retrieves the timestamp of the last time the game.ini file was modified.
					;Note: This timestamp will be the same as the GameLaunchSettingsFileModificationTime until the game saves its settings to the game.ini file after the game is closed.
					;Note 2: Checking modification times is necessary for slower computers because an arbitrary amount of time can pass before the closed game can modify the game.ini file, so the script has to wait for the game to be done saving to the file before the script can edit the file itself with the ResetGameScreenMode() function. 
					;https://www.autohotkey.com/docs/commands/FileGetTime.htm
					FileGetTime, GameCloseSettingsFileModificationTime, game.ini, M
					
					;Subtracts the current local time from the timestamp retrieved above.
					;https://www.autohotkey.com/docs/commands/EnvSub.htm
					EnvSub, GameCloseSettingsFileModificationTime, %A_Now%, seconds
					
					;Returns the absolute value of the time difference in seconds between the current local time and the game.ini file modification time. 
					;Note: This is used by the conditional below to check the game.ini file for modifications by the closed game repeatedly for up to 10 seconds in order the give the game enough time to save to the file before it is modified with the ResetGameScreenMode() function below.
					SecondsSinceGameSettingsFileModification := Abs(GameCloseSettingsFileModificationTime)
					
					if (SecondsSinceGameSettingsFileModification <= 10)
					{
						if (GameCloseSettingsFileModificationTime != GameLaunchSettingsFileModificationTime)
						{
							;Pauses the script temporarily in order to give the closed game enough time to save its settings to the game.ini file before it is modified with the function below.
							;Note: This is done as a secondary time buffer in case the file modification time is changed before the file is actually done being edited.
							Sleep, %WindowChangeBufferTime%
							
							;Changes the game screen mode to "windowed" in the game.ini file if it isn't already so the script can run correctly next time the game is launched by LilithPort. 
							ResetGameScreenMode()
							
							GameExitCleanupCompleted := true
						}
					}
				}
			}
		}
	}

	;Prevents the black background from showing on top of the game window by switching the window focus to the game window every time the black background gets focused (which would happen if you click the black background). 
	;Note: This is necessary because both the game window and the black background are set to be "AlwaysOnTop" of everything else on the screen, so whatever window is in focus shows on top of the other windows.
	if (BorderlessFullscreenActive = true)
	{
		if WinActive("ahk_id " BlackBackgroundHandle)
		{
			WinActivate, ahk_pid %GamePid%
		}
	}
	
	;Puts the game window and black background above the taskbar and everything else on the screen if the game window is currently focused and borderless fullscreen is active, or allows other windows to show on top of the game and black background if the game is not in focus.
	;Note: This allows alt+tab to be used to change windows. 
	if (BorderlessFullscreenActive = true)
	{
		if WinActive("ahk_pid " GamePid)
		{
			if (GameWindowActive = false)
			{
				WinSet, AlwaysOnTop, On, ahk_id %BlackBackgroundHandle%
				WinSet, AlwaysOnTop, On, ahk_pid %GamePid%

				GameWindowActive := true
			}
		}
		else
		{
			if (GameWindowActive = true)
			{
				WinSet, AlwaysOnTop, Off, ahk_id %BlackBackgroundHandle%
				WinSet, AlwaysOnTop, Off, ahk_pid %GamePid%
				
				GameWindowActive := false
			}
		}
	}
	else if (BorderlessFullscreenActive = false)
	{
		WinSet, AlwaysOnTop, Off, ahk_id %BlackBackgroundHandle%
		WinSet, AlwaysOnTop, Off, ahk_pid %GamePid%
		
		GameWindowActive := false
	}

	Return

;---------------------------------------

;Makes it so the hotkeys only run when the game window is focused.
;https://www.autohotkey.com/boards/viewtopic.php?t=65429
#If WinActive("ahk_pid " GamePid)

;Removes the ability to press F4 or Alt+Enter on the keyboard while the game window is focused so it is not possible to accidently go into the default broken fullscreen mode before the code that strips away the window borders and menu bar is executed. 
F4::Return
!Enter::Return

;---------------------------------------

;This section adds Fullscreen support.

;Hotkey that toggles fullscreen.
;Note: Switching back and forth several times between the fullscreen mode and the borderless modes may cause GUI problems randomly due to an unknown hidden issue (likely a problem with .dll calls), but the window change buffer time should prevent these issues from happening the majority of the time. 
;https://forums.thedarkmod.com/index.php?/topic/18313-a-borderless-fullscreen-windowed-solution-using-autohotkey/
;https://www.autohotkey.com/boards/viewtopic.php?t=13262
F5::

	BorderlessFullscreenActive := false
	Borderless4x3Active := false
	BorderlessStretchedActive := false
	BorderlessIntegerActive := false

	;Removes the black background.
	Gui, 3: Destroy

	if (FullscreenActive = false)
	{
		if (GameExeName != "vanpri.exe")
		{
			if (BordersHidden = false)
			{
				;Removes the window borders and menu bar from the game window. 
				HideBorders(WindowPositionX, WindowPositionY, WindowWidth, WindowHeight, hMenu, BordersHidden)
			}
		}
		
		;Enters fullscreen mode.
		ToggleFullscreen(WindowChangeBufferTime)
		
		FullscreenActive := true
	}
	else if (FullscreenActive = true)
	{
		;Exits fullscreen mode.
		ToggleFullscreen(WindowChangeBufferTime)

		if (BordersHidden = true)
		{
			;Adds the window borders and menu bar that were removed back to the game window.
			ShowBorders(WindowChangeBufferTime, WindowPositionX, WindowPositionY, WindowWidth, WindowHeight, hMenu, BordersHidden)
		}
		
		FullscreenActive := false
	}

	Return

;---------------------------------------

;This section adds Borderless Fullscreen (4:3) support.

F6::

	if (FullscreenActive = true)
	{
		;Exits fullscreen mode.
		ToggleFullscreen(WindowChangeBufferTime)
		
		FullscreenActive := false
	}
	
	;Calculates the new game window size. 
	BorderlessWindowHeight := A_ScreenHeight
	BorderlessWindowWidth := (4/3) * BorderlessWindowHeight
	
	if (BorderlessFullscreenActive = false)
	{
		if (BordersHidden = false)
		{
			;Removes the window borders and menu bar from the game window. 
			HideBorders(WindowPositionX, WindowPositionY, WindowWidth, WindowHeight, hMenu, BordersHidden)
		}

		;Resizes the game window.
		WinMove,,,,, %BorderlessWindowWidth%, %BorderlessWindowHeight%
		
		;Centers the game window on the screen. 
		WinMove,,, (A_ScreenWidth/2)-(BorderlessWindowWidth/2), (A_ScreenHeight/2)-(BorderlessWindowHeight/2)
		
		;Creates a black background GUI element that is placed over everything on screen except the game window in order to "fake" the fullscreen borderless window effect. 
		ShowBlackBackground()
		
		Borderless4x3Active := true
		BorderlessFullscreenActive := true
		
	}
	else if ((BorderlessStretchedActive = true) or (BorderlessIntegerActive = true))
	{
		;Resizes the game window.
		WinMove,,,,, %BorderlessWindowWidth%, %BorderlessWindowHeight%
		
		;Centers the game window on the screen. 
		WinMove,,, (A_ScreenWidth/2)-(BorderlessWindowWidth/2), (A_ScreenHeight/2)-(BorderlessWindowHeight/2)
		
		Borderless4x3Active := true
		BorderlessStretchedActive := false
		BorderlessIntegerActive := false
	}
	else if (BorderlessFullscreenActive = true)
	{
		;Removes the black background.
		Gui, 3: Destroy
		
		;Adds the window borders and menu bar that were removed back to the game window.
		ShowBorders(WindowChangeBufferTime, WindowPositionX, WindowPositionY, WindowWidth, WindowHeight, hMenu, BordersHidden)
		
		Borderless4x3Active := false
		BorderlessFullscreenActive := false
	}

	Return

;---------------------------------------

;This section adds Borderless Fullscreen (Stretched) support.

F7::

	if (FullscreenActive = true)
	{
		;Exits fullscreen mode.
		ToggleFullscreen(WindowChangeBufferTime)
		
		FullscreenActive := false
	}
	
	if (BorderlessFullscreenActive = false)
	{
		if (BordersHidden = false)
		{
			;Removes the window borders and menu bar from the game window. 
			HideBorders(WindowPositionX, WindowPositionY, WindowWidth, WindowHeight, hMenu, BordersHidden)
		}
		
		;Resizes the game window.
		WinMove,,,,, A_ScreenWidth, A_ScreenHeight
		
		;Centers the game window on the screen. 
		WinMove,,, 0, 0
		
		;Creates a black background GUI element that is placed over everything on screen except the game window in order to "fake" the fullscreen borderless window effect. 
		;Note: This is here to make the code that switches to other window modes work even though you won't see the black background in this window mode because the game window covers the whole screen.
		ShowBlackBackground()
		
		BorderlessFullscreenActive := true
		BorderlessStretchedActive := true
	}
	else if ((Borderless4x3Active = true) or (BorderlessIntegerActive = true))
	{
		;Resizes the game window.
		WinMove,,,,, A_ScreenWidth, A_ScreenHeight
		
		;Centers the game window on the screen. 
		WinMove,,, 0, 0
		
		Borderless4x3Active := false
		BorderlessStretchedActive := true
		BorderlessIntegerActive := false
	}
	else if (BorderlessFullscreenActive = true)
	{
		;Removes the black background.
		Gui, 3: Destroy
		
		;Adds the window borders and menu bar that were removed back to the game window.
		ShowBorders(WindowChangeBufferTime, WindowPositionX, WindowPositionY, WindowWidth, WindowHeight, hMenu, BordersHidden)
		
		BorderlessFullscreenActive := false
		BorderlessStretchedActive := false
	}

	Return

;---------------------------------------

;This section adds Borderless Fullscreen (Integer Scaled) support.

F8::

	if (FullscreenActive = true)
	{
		;Exits fullscreen mode.
		ToggleFullscreen(WindowChangeBufferTime)
		
		FullscreenActive := false
	}
	
	;Initializes variables for the window size calculations below. 
	BaseWindowWidth := 640
	BaseWindowHeight := 480
	ResolutionMultiplier := 0

	;Finds the first resolution multiplier that results in a window resolution that is too much for the monitor to display.
	while ((A_ScreenWidth >= (BaseWindowWidth * ResolutionMultiplier)) and (A_ScreenHeight >= (BaseWindowHeight * ResolutionMultiplier)))
	{
		ResolutionMultiplier := ResolutionMultiplier + 1
	}
	
	;Reduces the resolution multiplier by one so that the window resolutions calculated below fit within the monitor. 
	ResolutionMultiplier := ResolutionMultiplier - 1
	
	;Calculates the largest integer scaled game window size that can fit within the monitor.
	BorderlessWindowWidth := BaseWindowWidth * ResolutionMultiplier
	BorderlessWindowHeight := BaseWindowHeight * ResolutionMultiplier
	
	if (BorderlessFullscreenActive = false)
	{
		if (BordersHidden = false)
		{
			;Removes the window borders and menu bar from the game window. 
			HideBorders(WindowPositionX, WindowPositionY, WindowWidth, WindowHeight, hMenu, BordersHidden)
		}

		;Resizes the game window.
		WinMove,,,,, %BorderlessWindowWidth%, %BorderlessWindowHeight%
		
		;Centers the game window on the screen. 
		WinMove,,, (A_ScreenWidth/2)-(BorderlessWindowWidth/2), (A_ScreenHeight/2)-(BorderlessWindowHeight/2)
		
		;Creates a black background GUI element that is placed over everything on screen except the game window in order to "fake" the fullscreen borderless window effect. 
		ShowBlackBackground()
		
		BorderlessIntegerActive := true
		BorderlessFullscreenActive := true
	}
	else if ((Borderless4x3Active = true) or (BorderlessStretchedActive = true))
	{
		;Resizes the game window.
		WinMove,,,,, %BorderlessWindowWidth%, %BorderlessWindowHeight%
		
		;Centers the game window on the screen. 
		WinMove,,, (A_ScreenWidth/2)-(BorderlessWindowWidth/2), (A_ScreenHeight/2)-(BorderlessWindowHeight/2)
		
		Borderless4x3Active := false
		BorderlessStretchedActive := false
		BorderlessIntegerActive := true
	}
	else if (BorderlessFullscreenActive = true)
	{
		;Removes the black background.
		Gui, 3: Destroy
		
		;Adds the window borders and menu bar that were removed back to the game window.
		ShowBorders(WindowChangeBufferTime, WindowPositionX, WindowPositionY, WindowWidth, WindowHeight, hMenu, BordersHidden)
		
		BorderlessFullscreenActive := false
		BorderlessIntegerActive := false
	}

	Return

;---------------------------------------

;This section adds Default Window support.

F9::

	if (FullscreenActive = true)
	{
		;Exits fullscreen mode.
		ToggleFullscreen(WindowChangeBufferTime)
		
		FullscreenActive := false
	}
	
	if (BordersHidden = true)
	{
		;Adds the window borders and menu bar that were removed back to the game window.
		ShowBorders(WindowChangeBufferTime, WindowPositionX, WindowPositionY, WindowWidth, WindowHeight, hMenu, BordersHidden)
		
		BorderlessFullscreenActive := false
		Borderless4x3Active := false
		BorderlessStretchedActive := false
		BorderlessIntegerActive := false
	}
	
	;Removes the black background.
	Gui, 3: Destroy
	
	;Initializes variables that determine the default game window size.
	;Note: These resolution values include the window borders and menu bar, so the actual game resolution is displayed as 640 x 480.
	DefaultWindowWidth := 656
	DefaultWindowHeight := 558
	
	;Resizes the game window to a default size.
	WinMove,,,,, %DefaultWindowWidth%, %DefaultWindowHeight%
	
	;Centers the game window on the screen. 
	WinMove,,, (A_ScreenWidth/2)-(DefaultWindowWidth/2), (A_ScreenHeight/2)-(DefaultWindowHeight/2)
	
	Return
	
;---------------------------------------

